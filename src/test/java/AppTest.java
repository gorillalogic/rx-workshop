/*
 * This Java source file was generated by the Gradle 'init' task.
 */

import com.google.common.collect.Lists;
import io.reactivex.*;
import io.reactivex.disposables.CompositeDisposable;
import io.reactivex.disposables.Disposable;
import io.reactivex.schedulers.Schedulers;
import io.reactivex.schedulers.TestScheduler;
import io.reactivex.subjects.*;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.Random;
import java.util.concurrent.TimeUnit;

public class AppTest {

    Logger log = LoggerFactory.getLogger(AppTest.class);

    public static CompositeDisposable disposables;

    @BeforeClass
    public static void setUp() {
        disposables = new CompositeDisposable();
    }

    @Test
    public void createObservable() {

        Observable<Integer> observable = Observable.create(subscriber -> {
            log.info("Started emitting");

            log.info("Emitting 1st");
            subscriber.onNext(1);

            log.info("Emitting 2nd");

            subscriber.onNext(2);

            subscriber.onComplete();
        });

        log.info("Subscribing");

        //Please remember we should dispose each observer that have in our code. For it reason, please use Disposable class
        disposables.add(observable.subscribe(
                val -> log.info("Subscriber received: {}", val),
                err -> log.error("Subscriber received error", err),
                () -> log.info("Subscriber got Completed event")));

    }

    @Test
    public void createFlowable() {

        Flowable<Integer> flowable = Flowable.create(subscriber -> {
            log.info("Started emitting");

            log.info("Emitting 1st");
            subscriber.onNext(1);

            log.info("Emitting 2nd");
            subscriber.onNext(2);

            subscriber.onComplete();
        }, BackpressureStrategy.BUFFER);

        log.info("Subscribing");

        disposables.add(flowable.subscribe(
                val -> log.info("Subscriber received: {}", val),
                err -> log.error("Subscriber received error", err),
                () -> log.info("Subscriber got Completed event")));
    }

    @Test
    public void createSingleObservable() {

        Single<String> singleObservable = Single.create(subscriber -> {
            log.info("Started emitting");

            subscriber.onSuccess("It was successful");
        });

        log.info("Subscribing");

        disposables.add(singleObservable.subscribe(s -> log.info(s), error -> log.error(error.getMessage())));
    }

    @Test
    public void createSingleObservableThrowException() {

        Single<String> singleObservable = Single.create(subscriber -> {
            log.info("Started emitting");

            int sum = 1 / 0;

            subscriber.onSuccess("It was successful");
        });

        log.info("Subscribing");

        disposables.add(singleObservable.subscribe(s -> log.info(s), error -> log.error(error.getMessage())));
    }

    @Test
    public void createMaybeObservable() {

        Maybe<Object> maybeObservable = Maybe.create(emitter -> {

            log.info("Started emitting");

            emitter.onSuccess("Success");

            //emitter.onComplete();
        });

        log.info("Subscribing");

        disposables.add(maybeObservable.subscribe(s -> log.info(s.toString()), error -> log.error(error.getMessage())));
    }

    @Test
    public void createObservableUsingJust() {

        Flowable<Object> flowable = Flowable.just(1, 5, 10, "AD.2", true);

        disposables.add(flowable.subscribe(
                val -> System.out.println("Subscriber received: " + val),
                error -> log.info(error.getMessage()),
                () -> log.info("Completed")));
    }

    @Test
    public void createObservableUsingRange() {
        Flowable<Integer> flowable = Flowable.range(1, 10);

        disposables.add(flowable.subscribe(
                val -> System.out.println(("Subscriber received: " + val))));
    }

    @Test
    public void createObservableUsingFromArray() {
        Flowable<String> flowable = Flowable.fromArray(new String[]{"red", "green", "blue", "black"});

        disposables.add(flowable.subscribe(
                val -> System.out.println("Subscriber received: " + val),
                error -> log.info(error.getMessage()),
                () -> log.info("Completed")));
    }

    @Test
    public void createObservableUsingPublishSubject() {

        PublishSubject<String> subject = PublishSubject.create();
        subject.onNext("Hello");
        disposables.add(subject.subscribe(System.out::println));
        subject.onNext("Gorillas");
        subject.onNext("You're learning");
        subject.onNext("about Rx");
    }

    @Test
    public void createObservableUsingReplaySubject() {

        ReplaySubject<String> s = ReplaySubject.create();
        s.onNext("Hello");
        disposables.add(s.subscribe(value -> System.out.println("Observer1 listened: "+ value)));
        s.onNext("Gorillas");
        s.onNext("You're learning");
        s.onNext("about Rx");
        disposables.add(s.subscribe(value -> System.out.println("Observer2 listened: "+ value)));
    }

    @Test
    public void createObservableUsingBehaviorSubject() {

        BehaviorSubject<Integer> s = BehaviorSubject.create();
        s.onNext(0);
        s.onNext(1);
        s.onNext(2);
        disposables.add(s.subscribe(v -> System.out.println("Observer1 listened: " + v)));
        s.onNext(3);
        disposables.add(s.subscribe(v -> System.out.println("Observer2 listened: " + v)));
    }

    @Test
    public void createObservableUsingAsyncSubject() {

        AsyncSubject<String> s = AsyncSubject.create();
        s.onNext("I'm");
        s.onNext("a subject kind");
        disposables.add(s.subscribe(v -> System.out.println("Observer listened: "+ v)));
        s.onNext("Async");
        s.onComplete();
    }

    @AfterClass
    public static void clean() {
        //Here we're disposing our observer, we're cleaning the resources useless in order to avoid memory leaks.
        disposables.dispose();
    }


    @Test
    public void reduceObservableByFilter() {

        Observable<Integer> values = Observable.range(0,10);

        values.filter(value -> value % 2 == 0)
                .subscribe(new PrintSubscriber("Values received"));
    }

    @Test
    public void reduceObservableByDistinct() {

        Observable<Integer> values = Observable.just(1,1,1,2,4,6,1);

        values.distinct()
                .subscribe(new PrintSubscriber("Values received"));
    }

    @Test
    public void reduceObservableByDistinctUntilChanged() {

        Observable<Integer> values = Observable.just(1,1,1,2,4,6,1);

        values.distinctUntilChanged()
                .subscribe(new PrintSubscriber("Values received"));
    }

    @Test
    public void reduceObservableByTake() {

        Observable<Integer> values = Observable.just(1,1,1,2,4,6,1);

        values.take(4)
                .subscribe(new PrintSubscriber("Values received"));
    }

    @Test
    public void reduceObservableBySkip() {

        Observable<Integer> values = Observable.just(1,1,1,2,4,6,1);

        values.skip(2)
                .subscribe(new PrintSubscriber("Values received"));
    }

    @Test
    public void reduceObservableByExits() {

        Observable<Integer> values = Observable.just(1,1,1,2,4,6,1);

        values.isEmpty()
                .subscribe(value -> System.out.println(value));
    }

    @Test
    public void reduceObservableByContains() {

        Observable<Integer> values = Observable.just(1,1,1,2,4,6,1);

        values.contains(6)
                .subscribe(value -> System.out.println(value));
    }

    @Test
    public void inspectObservableByElementAt() {

        Observable<Integer> values = Observable.just(1,4,1,2,4,6,1);

        values.elementAt(1)
                .subscribe(value -> System.out.println(value));
    }

    @Test
    public void inspectObservableByCount() {

        Observable<Integer> values = Observable.just(1,4,1,2,4,6,1);

        values.count()
                .subscribe(value -> System.out.println(value));
    }


    @Test
    public void mappingObservables() {

        Observable<Integer> values = Observable.just("1","4","1","2","4","6","1")
                                        .map(Integer::parseInt);

        values.subscribe(value -> System.out.println(value + 1));
    }

    @Test
    public void flattingObservables() {
        Observable<Integer> values = Observable.just(3,8);

        values.flatMap(value -> Observable.range(0,value))
                .subscribe(value -> System.out.println(value.toString()));
    }

    @Test
    public void combineLatestObservables() {
        PublishSubject seq1 = PublishSubject.create();
        PublishSubject seq2 = PublishSubject.create();


        Observable.combineLatest(seq1, seq2,
                (value1, value2) -> value1 + " - "+ value2)
                .subscribe(combinedValue -> System.out.println(combinedValue));

        seq1.onNext("First emits 1");
        seq2.onNext("Second emits 1");

    }

    @Test
    public void concatObservables() {
        Observable<Integer> seq1 = Observable.range(0, 3);
        Observable<Integer> seq2 = Observable.range(10, 3);

        Observable.concat(seq1, seq2)
                .subscribe(System.out::println);

    }

    @Test
    public void mergeObservables() {
        PublishSubject seq1 = PublishSubject.create();
        ReplaySubject seq2 = ReplaySubject.create();

        seq2.onNext("Second: ".concat("1"));
        seq1.onNext("First: ".concat("1"));
        Observable.merge(seq1,seq2)
                .subscribe(System.out::println);
    }
}
